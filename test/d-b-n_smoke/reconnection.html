<!doctype html>
<html>

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">

    <title>Test suite for reconnection</title>
    <!-- Importing Web Component's Polyfill -->
    <script src="../../../webcomponentsjs/webcomponents.js"></script>
    <link rel="import" href="../shared/helpers.html">

    <script src="../../../web-component-tester/browser.js"></script>

    <!-- Step 1: import the element to test -->
    <link rel="import" href="../../palindrom-client.html">
</head>

<body>
    <test-fixture id="my-fixture">
        <template>
            <!-- workaround for test-fixture bug -->
            <div>
                <palindrom-client remote-url="/palindrom" ref="bind" ping-interval-s="0"></palindrom-client>
                <template is="dom-bind" id="bind">
                    <span id="name">{{model.name}}</span>
                </template>
            </div>
        </template>
    </test-fixture>
    <script>
        var model;
        // Do not take `console.error` as a reason to fail the test.
        WCT._config.trackConsoleError = false;
        describe('palindrom-client', function () {
            before(function initChai(done) {
                chai.use(palindromChaiPlugin);
                done();
            });
            var container, domBind, ppclient, palindrom, nameSpan, consoleErrorSpy;

            beforeEach(function (done) {
                patchAppliedEventCallback = sinon.spy();
                patchSentEventCallback = sinon.spy();
                consoleErrorSpy = sinon.spy(console, 'error');

                model = { "name": "oldname" };

                container = fixture('my-fixture');
                setTimeout(function () {
                    ppclient = container.querySelector("palindrom-client");
                    palindrom = ppclient.palindrom;
                    domBind = container.querySelector('template[is="dom-bind"]');
                    nameSpan = container.querySelector('#name');
                    initPalindrom(palindrom, model);
                    // Polymer werido(m)bind attaches to dom asynchronously
                    setTimeout(done, 100);
                }, 100);

            });
            afterEach(function (done) {
                console.error.restore();
                // Polymer werido(m)bind detaches from dom asynchronously
                setTimeout(function () {
                    done();
                }, 100);
            });

            it('when connection is broken with a reason should display an error box', function () {
                var closeEvent = { reason: 'thereason', code: 1 };
                var boxErrorMsg = 'Connection error. See console for details.';
                palindrom.network._ws.close(closeEvent);
                expect(container.querySelector("div.box.error.tappable").innerText).to.contain(boxErrorMsg);
            });

            it('and log error reason to the console', function () {
                var closeEvent = { reason: 'thereason', code: 1 };
                palindrom.network._ws.close(closeEvent);
                expect(consoleErrorSpy.getCall(0).args[0].message).to.contain(closeEvent.reason);
            });

            describe('when connection is broken without a reason should display a notice box', function () {
                it('and reconnect after a second and use model from server', function (done) {
                    var closeEvent = { reason: undefined, code: 1 };
                    palindrom.network._ws.close(closeEvent);
                    var newName = 'newname';
                    setMockServerModel({ name: newName });
                    expect(container.querySelector("div.box.notice").innerText).to.contain("Connecting in 1s...");
                    ppclient.addEventListener('reconnection-end', function () {
                        setTimeout(function () {
                            expect(nameSpan.innerText).to.equal(newName);
                            done();
                        }, 100);
                    });
                });

                it('and send pending patches when reconnecting', function (done) {
                    var closeEvent = { reason: undefined, code: 1 };
                    var newName = "new-name";
                    palindrom.network._ws.close(closeEvent);
                    domBind.set("model.name", newName);

                    ppclient.addEventListener('reconnection-end', function () {
                        expect(JSON.parse(lastRequestContent)[0][2]).to.deep.equal(
                            //            first patch ----^  ^---- first two operations are versions
                            operationObject('replace', '/name', newName));
                        done();
                    });
                });
            });
        });
    </script>

</body>

</html>