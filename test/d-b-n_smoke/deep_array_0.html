
<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">

    <title>Test suite for deep array operations</title>
    <!-- Importing Web Component's Polyfill -->
    <script src="../../../webcomponentsjs/webcomponents.js"></script>
    <link rel="import" href="../shared/helpers.html">

    <script src="../../../web-component-tester/browser.js"></script>

    <!-- Step 1: import the element to test -->
    <link rel="import" href="../../puppet-client.html">
</head>
<body>

    <test-fixture id="my-fixture"><template>
        <!-- workaround for test-fixture bug -->
        <div>
            <puppet-client remote-url="/puppet" ref="deep_array"></puppet-client>
            <template is="dom-bind" id="deep_array">
                <div id="arrayDiv">
                    <template is="dom-repeat" items="{{model.path_to.array}}">
                        <div id="nestedArrayDiv">
                          <template is="dom-repeat" items="{{item.nested_array}}">
                              <span>{{item.prop}}</span>
                          </template>
                        </div>
                    </template>
                </div>
            </template>
        </div>
    </template></test-fixture>
    <script>
        var model = {
            path_to: {
                array: [
                    {
                        nested_array: [
                            {//object that will be replaced
                                prop: "initial"
                            }
                        ]
                    }
                ]
            }
        };

describe('puppet-client, when stamped from `dom-bind` with deep attribute and bound to object w/ nested arrays', function () {
    var container, domBind, ppclient, puppet, patchAppliedEventCallback;

    beforeEach(function (done) {
        patchAppliedEventCallback = sinon.spy();

        container = fixture('my-fixture');
        setTimeout(function () {
            ppclient = container.querySelector("puppet-client");
            puppet = ppclient;
            puppet.obj = model;
            domBind = container.querySelector('template[is="dom-bind"]');
            domBind.model = model;
            // Polymer werido(m)bind attaches to dom asynchronously
            setTimeout(done, 100);
        }, 100);
    });
    afterEach(function (done) {
        // Polymer werido(m)bind detaches from dom asynchronously
        setTimeout(function () {
            done();
        }, 100);
    });

    describe('should notify Polymer binding so that changing nested array element will me replaced after each model replace', function () {
        it('fire a change event, and EVENTUALLY update dom-bind', function (done) {
            ppclient.addEventListener('patch-applied', patchAppliedEventCallback);
            // change model
            puppetChange(puppet, [operationObject('replace', '/path_to/array/0/nested_array/0', {prop: "firstChange"})]);

            // check and wait for async dom-bind's stamping
            setTimeout(function listener() {
                expect(patchAppliedEventCallback).to.have.been.called;
                expect( document.querySelector("#nestedArrayDiv>span:first-child").innerHTML ).to.equal("firstChange");

                var patchAppliedEventCallback2 = sinon.spy();
                ppclient.addEventListener('patch-applied', patchAppliedEventCallback2);
                // change model
                puppetChange(puppet, [operationObject('replace', '/path_to/array/0/nested_array/0', {prop: "secondChange"})]);

                // check and wait for async dom-bind's stamping
                setTimeout(function listener2() {
                    expect(patchAppliedEventCallback2).to.have.been.called;
                    expect( document.querySelector("#nestedArrayDiv>span:first-child").innerHTML ).to.equal("secondChange");
                    done();
                }, 100);

            }, 100);
        });
    });
});
    </script>

  </body>
</html>
